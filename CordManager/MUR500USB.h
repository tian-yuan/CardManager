/****************************************Copyright (c)**************************************************
**                                      TXRFID
**                                    
**                                 http://www.txrfid.com
**
**--------------文件信息-------------------------------------------------------------------------
**文   件   名: MUR500USB.H  
**创   建   人: TXRFID
**创 建 日  期: 2009年1月5日
**描        述: 动态库头文件。
**

  **-----------------修改记录--------------------------------------------------------------
  ** 当前版本:    v3.2 
  ** 修 改 人:    TXRFID
  ** 修改日期:    11.04.10
  ** 修改内容:    1. 所有函数以TX2开头,  函数的参数和返回值统一用UINT或者字符串型, 方便接口.

**-----------------修改记录--------------------------------------------------------------
** 修改内容:    1.
** 当前版本:    v1.00 
** 修 改 人:    TXRFID
** 修改日期:    2009年01月05日
** 注    意: 
**---------------------------------------------------------------------------------------

****************************************************************************************/
#ifndef __MUR500USB_H__
#define __MUR500USB_H__


#define MF1_S50                 0x04               
#define MF1_S70                 0x02
#define MF0_ULIGHT              0x44
#define MF1_LIGHT               0x10 

// PICC 命令
#define IDLE                    0x00
#define ALL                     0x01
#define ANTICOLLISION1          0x93       // anticollision level 1
#define ANTICOLLISION2          0x95       // anticollision level 2
#define ANTICOLLISION3          0x97       // anticollision level 3 
#define KEYA                    0x00       //密匙类型A
#define KEYB                    0x04       //密匙类型B
#define DECREMENT               0xC0
#define INCREMENT               0xC1
#define RESTORE                 0xC2

#define FALSE                   0
#define TRUE                    1
    
//定义数据块格式的位置
#define SEQNR                    0          //数据交换包的序号
#define COMMAND	                 1          //命令字符	
#define STATUS                   1          //状态字符
#define LENGTH                   2          //数据的长度		
#define DATA                     3          //数据字节

//mifare error
#define OK                      0          //函数调用成功
#define NO_TAG_ERR              -1          //在有效区域内没有卡
#define CRC_ERR                 -2          //从卡中接收到了错误的CRC校验和
#define EMPTY                   -3          //值溢出
#define AUTH_ERR                -4          //不能验证
#define PARITY_ERR              -5          //从卡中接收到了错误的校验位
#define CODE_ERR                -6          //通信错误


#define SERNR_ERR               -8          //在防冲突时读到了错误的串行码
#define KEY_ERR                 -9          //证实密码错*****
#define NOT_AUTH_ERR            -10         //卡没有验证
#define BIT_COUNT_ERR           -11         //从卡中接收到了错误数量的位
#define BYTE_COUNT_ERR          -12         //从卡中接收了错误数量的字节
#define TRANS_ERR               -14         //调用Transfer函数出错
#define WRITE_ERR               -15         //调用Write函数出错
#define INCR_ERR                -16         //调用Increment函数出错
#define DECR_ERR                -17         //调用Decrment函数出错
#define READ_ERR                -18         //调用Read函数出错
#define COLL_ERR                -24         //冲突错
#define ACCESS_TIMEOUT          -27         //访问超时
#define QUIT	                -30         //上一次了送命令时被打断
#define INVALID_PARA 31  // 无效参数
//check write Error
#define CHK_WR_OK               0          //Check Write正确
#define CHK_WR_FAILED           -1          //Check Write出错
#define CHK_WR_COMP_ERR         -2          //Check Write:写出错（比较出错）


#define COMM_ERR		255	//串行通信错误

#ifdef __cplusplus
	extern "C" { 
#endif


/*********************************************************************************************************
** 功能描述: 进行MUR500的USB初始化。
**
** 输　入:  无        
**
** 输　出:  无
**
** 函数返回: 参见函数返回值列表
**          
********************************************************************************************************/
UINT  __stdcall TX2_Init();


/*********************************************************************************************************
** 功能描述: 获取动态库版本号。
**
** 输　入:  无          
**
** 输　出:  版本号
**
** 函数返回: 参见函数返回值列表
**          
********************************************************************************************************/
void __stdcall TX_Get_Dll_Ver(char *ver);


/*********************************************************************************************************
** 功  能:  此函数的作用是将指定的密码装载到MUR-500内指定的密钥区，并非改变Mifare1 卡内扇区的密码。
**          本函数只对MUR-500进行操作，MUR-500与卡之间没有数据传输。MUR-500内有16 个密码区（区号0--15）,
**          称它为密钥区号。每个区分密钥A和密钥B两个，总共32 个密码。装载成功后，可用该密钥对Mifare1 卡进行验证。
**          在M1卡中也有16个存储区，称它为扇区号。若要改变Mifare1 卡内的密钥，可在用原密码验证通过后，
**          直接用写块数据TX_Write_Enc()函数，将密码块改写。Mifare卡出厂后的初始密钥为6个FFH，A和B密钥都一样。
**
** 输　入:  mode：密钥类型。可取值为mode＝0x00（KEYA）-密钥A，或mode＝0x04（KEYB）-密钥B。
**		    secnr：MUR-500内的密钥区号，取值范围：0～15
**			key：需要装载的密钥（6字节十六进制数据, 对应12个字符）
**                
** 输　出:  无
**
** 函数返回: 参见函数返回值列表
** 
** 例  子:  TX2_Load_Key(0x00, 0x01, "112233445566")
********************************************************************************************************/
UINT __stdcall TX2_Load_Key(UINT mode, UINT secnr, char *key);


/*********************************************************************************************************
** 功  能:  检查在TX模块有效范围内是否有卡存在。在选择一张新的卡时必须调用该函数。
**           卡片进入天线区域后，能获能能量，从而得电复位处于IDLE模块，TX_Request函数
**           可用ALL或IDLE任意一种模式进行请求，卡片均能响应，并返回卡片类型号TagType（2个字节）。
**           若对某一张卡成功进行了挂起操作（TX_Halt命令），卡片将进入Halt状态，此时的卡只能
**           响应ALL模式的请求，除非该卡离开天线区域然后再重新进入。
**           给TX模块发送0x41命令完成请求卡。
**           注意：对同一张卡（不进入HALT状态）连续进行请求时，总是一次成功一次失败
**
** 输　入: mode：请求模式 ReqCode取值为1或0 
**         mode＝0（IDLE），请求天线范围内IDLE状态的卡（HALT状态的除外）
**         mode＝1（ALL），请求天线范围内的所有卡。
**
**
** 输　出: TagType：卡片类型
**
**                +----+----+----+----+----+----+----+----+       +----+----+----+----+----+----+----+----+
**        MSByte  | b7 | b6 | b5 | b4 | b3 | b2 | b1 | b0 |LSByte | b7 | b6 | b5 | b4 | b3 | b2 | b1 | b0 |
**                +----+----+----+----+----+----+----+----+       +----+----+----+----+----+----+----+----+
**                |                 RFU                   |       |                                       | 
**                                                                | UID size| RFU|   bit-frame anticoll   |
**                                                                |         |    |                        |
**                                                                | 00..std |    |  (if any bit set .. Y, | 
**                                                                | 01..dbl |    |             else .. N) |
**                                                                | 10..tpl |    |                        |
**Mifare 1 S50    |                 RFU                   |       |  0   0    0    0  | 0    1    0    0  |  = 0x0004   UID(唯一序列号）4字节 比特帧防冲突方式
**Mifare 1 S70    |                 RFU                   |       |  0   0    0    0  | 0    0    1    0  |  = 0x0002   UID(唯一序列号）4字节 比特帧防冲突方式
**Mifare UltraLight|                RFU                   |       |  0   1    0    0  | 0    1    0    0  |  = 0x0044   UID(唯一序列号）7字节 比特帧防冲突方式，需二层防碰撞
**Mifare Light    |                 RFU                   |       |  0   0    0    1  | 0    0    0    0  |  = 0x0010   UID(唯一序列号）4字节 比特帧防冲突方式
**SHC1101         |                 RFU                   |       |  0   0    0    0  | 0    1    0    0  |  = 0x0004   UID(唯一序列号）4字节 比特帧防冲突方式
**SHC1102         | 0    0    1    1  |  0    0    1    1 |       |  0   0    0    0  | 0    0    0    0  |  = 0x3300   UID(唯一序列号）4字节 非比特帧防冲突方式               
**11RF32          |                 RFU                   |       |  0   0    0    0  | 0    1    0    0  |  = 0x0004   UID(唯一序列号）4字节 比特帧防冲突方式
**
** 函数返回: 参见函数返回值列表
**
********************************************************************************************************/
UINT __stdcall TX2_Request(UINT mode, UINT *tagtype);


/*********************************************************************************************************
** 功能描述: 可选级数的防碰撞操作。该函数必须在调用TX_Request命令后立即调用。当多个卡片位于天线区域时，
**           执行函数后，能得到序列号最大的那个卡片的序列号中的4个字节。
**           卡的序列号长度有三种：4字节、7字节和10字节。4字节的只要用一级防碰撞即可得到完整的序列号，
**           如Mifare1 S50 S70等；7字节的要进行二级防碰撞才能得到完整的序列号，前一级所得到的序列号的
**           最低字节为级联标志0x88，在序列号内只后3字节可用，后一级防碰撞能得到4字节序列号，两者按顺序
**           连接即为7字节序列号，如UltraLight和DesFire等；10字节的以此类推，但至今没有此类卡。
**           需要进行二级防碰撞操作，可通过修改参数Select_Code来实现。第一级使用Select_Code＝0x93，
**           第二级使用Select_Code＝0x95,对于现在所有得Mifare卡，不需要进行三级防碰撞，因为所有Mifare卡的序列号
**           最大为7个字节。当知道了所要选择卡的序列号后，就没有必要执行该TX_AntiColl函数。此时，调用TX_Request后，
**           直接调用TX_Select函数即可。
**           
** 输　入:  code：防碰撞层级编码：一层（ANTICOLL1）-0x93；二层（ANTICOLL2）-0x95；三层（ANTICOLL3）-0x97。
**          bcnt：预选卡已经知道的序列号的的位数，通常都设置Bcnt=0。
**      
** 输　出:  snr：卡的序列号。若卡的序列号超过4个字节（如Mifare UltraLight），序列号不完整，则最低字节的值为0x88，
**               表示需要进行更高一级的防碰撞TX2_Casc_Anticoll（0x95）。
**
** 函数返回: 参见函数返回值列表
**
********************************************************************************************************/
UINT __stdcall TX2_Casc_Anticoll(UINT bcnt, UINT code, ULONG *snr);

/*********************************************************************************************************
** 功能描述: 该函数选择某一个序列号的卡，与之建立通信连接，并返回是否选择成功的应答*Sak。
**           该函数一般与TX_Casc_Anticoll()配对使用，进行多级防碰撞后卡的选择。
**           参数Select_Code表示防碰撞的级数，应该与该函数执行前的TX_Casc_Anticoll()中的Select_Code相同.
**           在任意一个防碰撞函数成功执行后，或在任何时候当程序员想实际地与已知序列号的卡片进行通信时，
**           必须使用TX_Casc_Select或后面得TX_Select函数，以建立与所选卡的通信。
**           卡的序列号长度有三种：4字节、7字节和10字节。4字节的只要用一级选择即可,如Mifare1 S50 S70等；
**           7字节的要用二级选择才能完成，如UltraLight和DesFire等。如果需要进行二级选择，第一级选择输入
**           的序列号为，第一级防碰撞所得到的序列号,其中最低字节为级联标志0x88，只后3字节可用，第二级选
**           择输入得序列号为第二级防碰撞得到4字节序列号。
**           在程序中可用*Sak的bit2位来判断是否还有序列号未读出，如if(*SAK & 0x04){…}
**
** 输　入:  code：防碰撞层级编码：一层（ANTICOLL1）-0x93；二层（ANTICOLL2）-0x95；三层（ANTICOLL3）-0x97。
**                该参数应该与之前的TX2_Casc_Anticoll()中的Select_Code参数相同。
**          snr：前一次防碰撞返回的卡的序号，或已知的卡的序列号。如果卡得序号号大于4个字节，
**               则snr的最低字节值为0x88，表示需要进行更高一级的防碰撞。
** 输　出:  sak：是否选择成功的应答,其意义如下：
**
**                +----+----+----+----+----+----+----+----+
**       *Sak     | b7 | b6 | b5 | b4 | b3 | b2 | b1 | b0 |
**                +----+----+----+----+----+----+----+----+
**                |   RFU   |diff|   RFU   | ok |   RFU   | 
**Mifare 1 S50    |  0   0    0    0  |  1    0    0   0  |  = 0x08   
**Mifare 1 S70    |  0   0    0    1  |  1    0    0   0  |  = 0x18 
**Mifare UltraLight| 0   0    0    0  |  0    1    0   0  |  = 0x04 （第1次选择）
**Mifare Light    |  0   0    0    0  |  0    0    0   1  |  = 0x01 
**SHC1101         |  0   0    1    0  |  0    0    1   0  |  = 0x22 
**11RF32          |  0   0    0    0  |  1    0    0   0  |  = 0x08 
**
** bit2位用来判断是否还有序列号未读出，bit2＝0时，表示所有序列号输入完毕，选择成功，
** bit2＝1时表示序列号没有全部输入，选择没有完全成功，还要进行下一级的防碰撞和选择操作。
**	xxxxx1xx: 序号号没有完成，还要进行下一级的防碰撞和选择操作。
**	xx1xx0xx: 选择成功，该卡符合ISO/IEC 14443-4标准
**	xx0xx0xx: 选择成功，该卡不符合ISO/IEC 14443-4标准
**
** 函数返回: 参见函数返回值列表
**
*********************************************************************************************************/
UINT __stdcall TX2_Casc_Select(UINT code,unsigned long snr, UINT *sak);

/*********************************************************************************************************
** 功能描述: 使用MUR-500内部密钥区keynr中的密码对指定的卡的扇区secnr进行验证，若卡secnr区中的密码
**           与存储在MUR-500内secnr中的密码相同，则验证成功，返回OK。
**           该函数依赖于TX2_Load_Key函数曾经成功执行过，因为MUR-500内部密码区（keynr）中的密码要由TX2_Load_Key函数
**           事先装载。该函数适用于对于所有卡来说密码相同的应用，密钥的装载可以在一个安全的场合一次性装入。

**
** 输　入:   mode：密钥类型（1字节）。可取值为mode＝0x00（KEYA），利用密钥A进行验证; 或mode＝0x04（KEYB），利用密钥B进行验证。
**           secnr：所要验证的卡扇区号（也即将要访问的卡的扇区号），取值范围0～39，能用于S70卡。
**           keynr：MUR-500内的密钥区号：取值范围0～15。
**
** 输　出: 无
**
** 函数返回: 参见函数返回值列表
********************************************************************************************************/
UINT __stdcall TX2_Auth2(UINT mode,UINT secnr,UINT keynr);



/*********************************************************************************************************
** 功能描述: TX2_Auth2函数必须要依赖于TX2_Load_Key()函数的曾经的成功执行，在进行证实之前，一定要确认正确的密钥
**           已经存于MUR-500的密钥区内。而TX2_Auth_Key函数则直接将密钥传送到MUR内对卡片进行验证。TX2_Auth_Key函数
**           执行时不对密钥区进行操作，因此也称为直接密码证实。若卡中的密钥与所传输的密码相匹配，则证实成功，函数将返回OK。
**           直接密码证实一般用于对每一张卡来说密钥都不同的应用，如在使用安全模块（PSAM卡）的消费应用中，
**           消费机首先将卡的序列号读出，然后与PSAM卡中消费主密钥一起生成导出密钥，然后直接用导出密钥与卡的一个应用扇区相互证实
**
** 输　入:   mode：密钥类型。可取值为mode＝0x00（KEYA），利用密钥A进行验证；或mode＝0x04（KEYB），利用密钥B进行验证。
**           key：用于证实的密码（6字节十六进制数据，对应12个字符）；
**           secnr：所要验证的卡扇区号（也即将要访问的卡的扇区号），取值范围0～39，能用于S70卡。
**
** 输　出: 无
**
** 函数返回: 参见函数返回值列表
**
** 例  子:  TX2_Auth_Key(0x00, "112233445566", 1)
********************************************************************************************************/
UINT __stdcall TX2_Auth_Key(UINT mode, char *key,UINT secnr);



/*********************************************************************************************************
** 功能描述: 在验证成功后，使用该函数读Mifare卡中相应块的数据。Mifare卡中一个块的数据是16字节，因此读写
**           一次均是16个字节。所读块号必须与之前所验证的块号在同一个扇区内，mifare1卡从块号0开始按顺序
**           每4个块1个扇区。
**           因为Mifare卡每个扇区的密码可能不相同，若要对一张卡中的多个扇区进行操作，在对某一扇区操作
**           完毕后，必须进行一条读命令才能对另一个扇区直接进行验证命令，否则必须从请求开始操作。
**           密码数据不能被读取。                   
**
** 输　入: addr：卡块号：	S50：0～63；S70：0～255
**
** 输　出: data：为读回数据的首地址。读回的为16字节的十六进制数据，对应32个字符。例如读取到"00112233445566778899AABBCCDDEEFF"。
**
** 函数返回: 参见函数返回值列表
********************************************************************************************************/
UINT __stdcall TX2_Read_Enc(UINT addr, char *data);


/*********************************************************************************************************
** 功能描述:读出卡内某一块值块。
**
** 输　入:  addr --卡块号：			S50：1~63
									S70：1~255
**                
** 输　出:  value：4字节值块值。
**
** 函数返回: 参见函数返回值列表
**           
********************************************************************************************************/
UINT __stdcall TX2_Read_Val(UINT addr, unsigned long *value);


/*********************************************************************************************************
** 功能描述: 对卡内某一块进行验证成功后，即可对同一扇区的各个块进行写操作（只要访问条件允许），
**           其中包括位于扇区尾的密码块，这是更改密码的唯一方法。。                   
**
** 输　入: addr：卡块号：	S50：1～63；S70：1～255  第0块不能写
**         data：要写入的数据（16字节的十六进制数据，对应32个字符）
**
** 输　出: 无
**
** 函数返回: 参见函数返回值列表
**
   例  子: TX2_Write_Enc(1, "00112233445566778899AABBCCDDEEFF")
********************************************************************************************************/
UINT __stdcall TX2_Write_Enc(UINT addr, char *data);




/*********************************************************************************************************
** 功能描述: 对UltraLight卡写入一个4字节的数据。此命令只对UltraLight有效。对UltraLight进行读操作与mifare1一样。                   
**           
** 输　入: addr：卡块号：	0～15
           data：要写入的数据（4字节的十六进制数据，对应8个字符）
**
** 输　出: 无
**
** 函数返回: 参见函数返回值列表。
** 例  子: TX2_ULwrite_Enc(1, "11223344")
*********************************************************************************************************/
UINT __stdcall TX2_ULwrite_Enc(UINT addr, char* data);


/*********************************************************************************************************
** 功能描述: 往Mifare卡中相应块写入值块格式的数据。
**
** 输　入: addr --卡块号：		        S50：1~63
**									    S70：1~255
**         value：4字节数据，用来存储减少值或增加值，当进行恢复操作时，该值为空值。
**                
** 输　出:  无。
**
** 函数返回: 参见函数返回值列表
**           
********************************************************************************************************/
UINT __stdcall TX2_Write_Val(UINT addr,long value);



/*********************************************************************************************************
** 功能描述: 此函数对卡内的某一块进行加、减或数据备份，该块必须为值块格式。若卡块号与传输块号相同，
**           则将操作后的结果写入原来的块内；若卡块号与传输块号不相同，则将操作后的结果写入传输块内，
**           而原块内的值不变。当模式为"恢复"时，"值"无意义。     
**  
** 输　入: mode：0xC0-减； 0xC1-加； 0xC2-恢复
**         addr：卡内块地址，对该块进行值操作，也就是源地址。取值范围：S50：1～63；S70：1～255
**         value：4字节数据，用来存储减少值或增加值，当进行恢复操作时，该值为空值。
**         trans_addr：传输块地址，也就是结果保存地址。取值范围：S50：1～63；S70：1～255。
**
**
** 输　出: 无
**
** 函数返回: 参见函数返回值列表
**
********************************************************************************************************/
UINT __stdcall TX2_Value(UINT mode,UINT addr,long value,UINT trans_addr);



/*********************************************************************************************************
** 功能描述: 将天线区所选择卡置为挂起状态。如果要进行重新选择，则应用ALL模式调用TX_Request命令。
**           如果要进行重新选择,也可以将卡离开天线操作区再进入，或执行复位函数TX_Reset()。
**           可以配合使用TX_Request()和TX_Halt()函数，进行一次性扣费，如卡进入感应区后只扣一次（一元钱），
**           离开后，下次进入再扣一次，若卡在感应区内停留时间较长，也不会扣多一次。
**
** 输　入: 无
**
** 输　出: 无
**
** 函数返回: 参见函数返回值列表
**
********************************************************************************************************/
UINT __stdcall TX2_Halt(void);


/*********************************************************************************************************
** 功能描述: 此函数设置绿灯熄灭。
**  
** 输　入: 无 
**
** 输　出: 无
**
** 函数返回: 参见函数返回值列表
**
********************************************************************************************************/
UINT __stdcall TX2_Green_Off();

/*********************************************************************************************************
** 功能描述: 此函数设置绿灯亮
**  
** 输　入: 无 
**
** 输　出: 无
**
** 函数返回: 参见函数返回值列表
**
********************************************************************************************************/
UINT __stdcall TX2_Green_On();


/*********************************************************************************************************
** 功能描述: 此函数输出一方波用于驱动蜂鸣器、绿灯，驱动的频率、持续时间、间隙时间和重复次数可设定。
**
** 输　入: Control:	 控制字，Control = 0x01时，控制对象为蜂鸣器，Control = 0x02时，控制对象为绿灯，
           Control = 0x03时，绿灯和蜂鸣器同时控制。。 
**             
**         OpenTime:	 方波输出持续时间，取值（0～255），10ms的分辨率
**         CloseTime:	 间隙时间，取值（0～255），10ms的分辨率
**         RepCnt:	 重复次数
**
** 输　出: 无
**
** 函数返回: 参见函数返回值列表
**
*******************************************************************************************************/
UINT __stdcall TX2_Alarm(UINT contrl,UINT opentm,UINT closetm,UINT repcnt);


/*=============================================================================
函数名：	void Hex2Char(BYTE *hexStr, char *dstBuf, short hexLen)

功能描述： 把16进制数转成可见字符串，方便显示

输入参数： hexStr -- 16进制数组
           hexLen -- 16进制数的字节数

输出参数： dstBuf -- 输出字符串， 长度为16进制数组的长度的2倍 + 1

返回值：   无
=============================================================================*/
void Hex2Char(BYTE *hexStr, char *dstBuf, long hexLen)
{
	short i;

    strcpy(dstBuf, "");
	for (i = 0; i < hexLen; i++)
	{
        sprintf(&dstBuf[i*2], "%02X", hexStr[i]);
	}
}

/*=============================================================================
函数名：	void Str2Hex(char *str, BYTE *hex, short strLen)

功能描述： 把字符串转成16进制

输入参数： str -- 字符串
           strLen -- 字符串的字节数

输出参数： hex -- 16进制数组，长度为strLen/2

返回值：   无
=============================================================================*/
void Str2Hex(char *str, BYTE *hex, short strLen)
{
	short i;
    char buf[16] = {0};

    for (i = 0; i < strLen/2; i++)
    {
        memcpy(buf, &str[i*2], 2);

        hex[i] = (BYTE)(strtol(buf, NULL, 16));
    }    
}










/***************************************************************************/
/***************************************************************************/


///////////////////////////////////////////////////////////////////////////////
#ifdef __cplusplus
   }
#endif

#endif  